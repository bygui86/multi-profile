// Package profile provides a simple way to manage multiple runtime/pprof profiling of your Go application
package profile

import (
	"fmt"
	"io/ioutil"
	"os"
	"os/signal"
	"path/filepath"
	"runtime"
	"runtime/pprof"
	"runtime/trace"
	"sync/atomic"
	"syscall"

	"github.com/bygui86/multi-profile/logging"
)

const (
	cpuMode = iota
	memMode
	mutexMode
	blockMode
	traceMode
	threadCreationMode
	goroutineMode

	DefaultPath = "./"

	// DefaultMemProfileRate is the default memory profiling rate.
	// See also http://golang.org/pkg/runtime/#pkg-variables
	DefaultMemProfileRate = 4096

	// DefaultMemProfileRate is the default memory profiling type.
	DefaultMemProfileType = MemProfileHeap

	MemProfileHeap   MemProfileType = "heap"
	MemProfileAllocs MemProfileType = "allocs"

	cpuPprofDefaultFilename       = "cpu.pprof"
	memPprofDefaultFilename       = "mem.pprof"
	mutexPprofDefaultFilename     = "mutex.pprof"
	blockPprofDefaultFilename     = "block.pprof"
	tracePprofDefaultFilename     = "trace.pprof"
	threadPprofDefaultFilename    = "threadcreate.pprof"
	goroutingPprofDefaultFilename = "goroutine.pprof"

	mutexPprof     = "mutex"
	blockPprof     = "block"
	threadPprof    = "threadcreate"
	goroutinePprof = "goroutine"
)

// MemProfileType defined which type of memory profiling you want to start
type MemProfileType string

// Profile represents a profiling session
type Profile struct {
	// mode holds the type of profiling that will be made.
	mode int

	/*
		path holds the base path where various profiling files are  written.
		If blank, the base path will be the current directory "./"
	*/
	path string

	// useTempPath let the path be generated by "ioutil.TempDir"
	useTempPath bool

	// filename holds the filename created by starting the profiling
	filename string

	// disableShutdownHook controls whether the profiling package should hook SIGINT to write profiles cleanly.
	disableShutdownHook bool

	// quiet suppresses informational messages during profiling.
	quiet bool

	/*
		memProfileRate holds the rate for the memory profile.
		See DefaultMemProfileRate for default value.
	*/
	memProfileRate int

	/*
		memProfileType holds the type for the memory profile.
		Available values:   heap | allocs
		See DefaultMemProfileType for default.
	*/
	memProfileType MemProfileType

	// internalCloser holds the internal cleanup function that run after profiling Stop.
	// This function is specific for each profile (CPU, MEM, GoRoutines, etc)
	internalCloser func()

	// closerHook holds a custom cleanup function that run after profiling Stop.
	closerHook func()

	// Logger offers the possibility to inject a custom logger.
	logger logging.Logger

	// started records if a call to profile.Start has already been made.
	started uint32
}

// ProfileConfig holds configurations to create a new Profile
type ProfileConfig struct {
	/*
		Path holds the base path where various profiling files are  written.
		If blank, the base path will be the current directory "./"
	*/
	Path string

	// UseTempPath let the path be generated by "ioutil.TempDir"
	UseTempPath bool

	// DisableShutdownHook controls whether the profiling package should hook SIGINT to write profiles cleanly.
	DisableShutdownHook bool

	// Quiet suppresses informational messages during profiling.
	Quiet bool

	/*
		MemProfileRate holds the rate for the memory profile.
		See DefaultMemProfileRate for default value.
	*/
	MemProfileRate int

	/*
		MemProfileType holds the type for the memory profile.
		Available values:   heap | allocs
		See DefaultMemProfileType for default.
	*/
	MemProfileType MemProfileType

	// CloserHook holds a custom cleanup function that run after profiling Stop.
	CloserHook func()

	// Logger offers the possibility to inject a custom logger.
	Logger logging.Logger
}

// CPUProfile creates a CPU profiling object
func CPUProfile(cfg *ProfileConfig) *Profile {
	return &Profile{
		mode:                cpuMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// MemProfile creates a memory profiling object
func MemProfile(cfg *ProfileConfig) *Profile {
	memRate := DefaultMemProfileRate
	memType := DefaultMemProfileType
	if cfg.MemProfileRate > 0 {
		memRate = cfg.MemProfileRate
	}
	if cfg.MemProfileType != "" {
		memType = cfg.MemProfileType
	}

	return &Profile{
		mode:                memMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		memProfileRate:      memRate,
		memProfileType:      memType,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// MutexProfile creates a mutex profiling object
func MutexProfile(cfg *ProfileConfig) *Profile {
	return &Profile{
		mode:                mutexMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// BlockProfile creates a block (contention) profiling object
func BlockProfile(cfg *ProfileConfig) *Profile {
	return &Profile{
		mode:                blockMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// TraceProfile creates an execution tracing profiling object
func TraceProfile(cfg *ProfileConfig) *Profile {
	return &Profile{
		mode:                traceMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// ThreadCreationProfile creates a thread creation profiling object
func ThreadCreationProfile(cfg *ProfileConfig) *Profile {
	return &Profile{
		mode:                threadCreationMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// GoroutineProfile creates a goroutine profiling object
func GoroutineProfile(cfg *ProfileConfig) *Profile {
	return &Profile{
		mode:                goroutineMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// Start starts a new profiling session
func (p *Profile) Start() *Profile {
	if !atomic.CompareAndSwapUint32(&p.started, 0, 1) {
		// no-op, profiling already started
		return p
	}

	var pathErr error
	if p.useTempPath {
		pathErr = p.prepareTempPath()
	} else {
		pathErr = p.preparePath()
	}
	if pathErr != nil {
		// TODO replace with specific logger method
		p.log("[FATAL] profiling start aborted, could not create output directory: %s", pathErr.Error())
		os.Exit(11)
	}

	switch p.mode {
	case cpuMode:
		p.startCpuMode()

	case memMode:
		p.startMemMode()

	case mutexMode:
		p.startMutexMode()

	case blockMode:
		p.startBlockMode()

	case traceMode:
		p.startTraceMode()

	case threadCreationMode:
		p.startThreadCreationMode()

	case goroutineMode:
		p.startGoroutineMode()
	}

	p.startShutdownHook()
	return p
}

// Stop stops the profiling and flushes any unwritten data.
// The caller should call the Stop method on the value returned to cleanly stop profiling.
func (p *Profile) Stop() {
	if !atomic.CompareAndSwapUint32(&p.started, 1, 0) {
		// no-op, profiling already stopped
		return
	}

	if p.internalCloser != nil {
		p.internalCloser()
	}

	if p.closerHook != nil {
		p.closerHook()
	}
}

// preparePath prepares the file path to flush data into when profiling will be stopped
func (p *Profile) preparePath() error {
	if p.path == "" {
		p.path = DefaultPath
	}

	if p.path != DefaultPath {
		mkdirErr := os.MkdirAll(p.path, 0777)
		if mkdirErr != nil {
			return mkdirErr
		}
	}

	return nil
}

// preparePath prepares the file path in 'tmp' folder to flush data into when profiling will be stopped
func (p *Profile) prepareTempPath() error {
	var err error
	p.path, err = ioutil.TempDir("", "profile_")
	if err != nil {
		return err
	}
	return nil
}

// startCpuMode starts cpu profiling
func (p *Profile) startCpuMode() {
	p.filename = filepath.Join(p.path, cpuPprofDefaultFilename)
	file, fileErr := os.Create(p.filename)
	if fileErr != nil {
		// TODO replace with specific logger method
		p.log("[FATAL] CPU profiling file %q creation failed: %s", p.filename, fileErr.Error())
		os.Exit(12)
	}

	startErr := pprof.StartCPUProfile(file)
	if startErr != nil {
		// TODO replace with specific logger method
		p.log("[FATAL] CPU profiling start failed: %s", startErr.Error())
		os.Exit(13)
	}
	p.internalCloser = p.stopAndFlush(file, -1)

	// TODO replace with specific logger method
	p.log("[INFO] CPU profiling enabled, file %s", fmt.Sprintf("%s%s", p.path, p.filename))
}

// startMemMode starts memory profiling
func (p *Profile) startMemMode() {
	p.filename = filepath.Join(p.path, memPprofDefaultFilename)
	file, err := os.Create(p.filename)
	if err != nil {
		// TODO replace with specific logger method
		p.log("[FATAL] Memory profiling (%s) file %q creation failed: %s", p.memProfileType, p.filename, err.Error())
		os.Exit(12)
	}

	previous := runtime.MemProfileRate
	runtime.MemProfileRate = p.memProfileRate
	p.internalCloser = p.stopAndFlush(file, previous)

	// TODO replace with specific logger method
	p.log("[INFO] Memory profiling (%s) enabled at rate %d, file %s",
		p.memProfileType, runtime.MemProfileRate, fmt.Sprintf("%s%s", p.path, p.filename))
}

// startMutexMode starts mutes profiling
func (p *Profile) startMutexMode() {
	p.filename = filepath.Join(p.path, mutexPprofDefaultFilename)
	file, err := os.Create(p.filename)
	if err != nil {
		// TODO replace with specific logger method
		p.log("[FATAL] Mutex profiling file %q creation failed: %s", p.filename, err.Error())
		os.Exit(12)
	}

	runtime.SetMutexProfileFraction(1)
	p.internalCloser = p.stopAndFlush(file, -1)

	// TODO replace with specific logger method
	p.log("[INFO] Mutex profiling enabled, file %s", fmt.Sprintf("%s%s", p.path, p.filename))
}

// startBlockMode starts block profiling
func (p *Profile) startBlockMode() {
	p.filename = filepath.Join(p.path, blockPprofDefaultFilename)
	file, err := os.Create(p.filename)
	if err != nil {
		// TODO replace with specific logger method
		p.log("[FATAL] Block profiling file %q creation failed: %s", p.filename, err.Error())
		os.Exit(12)
	}

	runtime.SetBlockProfileRate(1)
	p.internalCloser = p.stopAndFlush(file, -1)

	// TODO replace with specific logger method
	p.log("[INFO] Block profiling enabled, file %s", fmt.Sprintf("%s%s", p.path, p.filename))
}

// startTraceMode starts trace profiling
func (p *Profile) startTraceMode() {
	p.filename = filepath.Join(p.path, tracePprofDefaultFilename)
	file, fileErr := os.Create(p.filename)
	if fileErr != nil {
		// TODO replace with specific logger method
		p.log("[FATAL] Trace profiling file %q creation failed: %s", p.filename, fileErr.Error())
		os.Exit(12)
	}

	startErr := trace.Start(file)
	if startErr != nil {
		// TODO replace with specific logger method
		p.log("[FATAL] Trace profiling start failed: %s", startErr.Error())
		os.Exit(14)
	}
	p.internalCloser = p.stopAndFlush(file, -1)

	// TODO replace with specific logger method
	p.log("[INFO] Trace profiling enabled, file %s", fmt.Sprintf("%s%s", p.path, p.filename))
}

// startThreadCreationMode starts thread creation profiling
func (p *Profile) startThreadCreationMode() {
	p.filename = filepath.Join(p.path, threadPprofDefaultFilename)
	file, err := os.Create(p.filename)
	if err != nil {
		// TODO replace with specific logger method
		p.log("[FATAL] Thread creation profiling file %q creation failed: %s", p.filename, err.Error())
		os.Exit(12)
	}
	p.internalCloser = p.stopAndFlush(file, -1)

	// TODO replace with specific logger method
	p.log("[INFO] Thread creation profiling enabled, file %s", fmt.Sprintf("%s%s", p.path, p.filename))
}

// startGoroutineMode starts goroutine profiling
func (p *Profile) startGoroutineMode() {
	p.filename = filepath.Join(p.path, goroutingPprofDefaultFilename)
	file, err := os.Create(p.filename)
	if err != nil {
		// TODO replace with specific logger method
		p.log("[FATAL] Goroutine profiling file %q creation failed: %s", p.filename, err.Error())
		os.Exit(12)
	}
	p.internalCloser = p.stopAndFlush(file, -1)

	// TODO replace with specific logger method
	p.log("[INFO] Goroutine profiling enabled, file %s", fmt.Sprintf("%s%s", p.path, p.filename))
}

// stopAndFlush stops profiling and flush data to file
func (p *Profile) stopAndFlush(file *os.File, previousMemRate int) func() {
	switch p.mode {

	case cpuMode:
		return p.stopCpuMode(file)

	case memMode:
		return p.stopMemMode(file, previousMemRate)

	case mutexMode:
		return p.stopMutexMode(file)

	case blockMode:
		return p.stopBlockMode(file)

	case traceMode:
		return p.stopTraceMode()

	case threadCreationMode:
		return p.stopThreadCreationMode(file)

	case goroutineMode:
		return p.stopGoroutineMode(file)

	// WARN: we should never reach default!
	default:
		return p.stopUnknownMode()
	}
}

// stopCpuMode stops cpu profiling
func (p *Profile) stopCpuMode(file *os.File) func() {
	return func() {
		pprof.StopCPUProfile()
		err := file.Close()
		if err != nil {
			p.log("[ERROR] CPU profiling flushing data to file %q failed: %s", p.filename, err.Error())
		}

		p.log("[INFO] CPU profiling disabled, file %s", fmt.Sprintf("%s%s", p.path, p.filename))
	}
}

// stopMemMode stops memory profiling
func (p *Profile) stopMemMode(file *os.File, previousMemRate int) func() {
	return func() {
		pprofile := pprof.Lookup(string(p.memProfileType))
		if pprofile != nil {
			err := pprofile.WriteTo(file, 0)
			if err != nil {
				p.log("[ERROR] Memory profiling flushing data to file %q failed: %s", p.filename, err.Error())
			}
		} else {
			p.log("[ERROR] Memory profiling flushing data to file %q failed: pprof lookup returned null", p.filename)
		}

		err := file.Close()
		if err != nil {
			p.log("[ERROR] Memory profiling flushing data to file %q failed: %s", p.filename, err.Error())
		}

		runtime.MemProfileRate = previousMemRate
		p.log("[INFO] Memory profiling disabled, file %s", fmt.Sprintf("%s%s", p.path, p.filename))
	}
}

// stopMutexMode stops mutex profiling
func (p *Profile) stopMutexMode(file *os.File) func() {
	return func() {
		pprofile := pprof.Lookup(mutexPprof)
		if pprofile != nil {
			err := pprofile.WriteTo(file, 0)
			if err != nil {
				p.log("[ERROR] Mutex profiling flushing data to file %q failed: %s", p.filename, err.Error())
			}
		} else {
			p.log("[ERROR] Mutex profiling flushing data to file %q failed: pprof lookup returned null", p.filename)
		}

		err := file.Close()
		if err != nil {
			p.log("[ERROR] Mutex profiling flushing data to file %q failed: %s", p.filename, err.Error())
		}

		runtime.SetMutexProfileFraction(0)
		p.log("[INFO] Mutex profiling disabled, file %s", fmt.Sprintf("%s%s", p.path, p.filename))
	}
}

// stopBlockMode stops block profiling
func (p *Profile) stopBlockMode(file *os.File) func() {
	return func() {
		pprofile := pprof.Lookup(blockPprof)
		if pprofile != nil {
			err := pprofile.WriteTo(file, 0)
			if err != nil {
				p.log("[ERROR] Block profiling flushing data to file %q failed: %s", p.filename, err.Error())
			}
		} else {
			p.log("[ERROR] Block profiling flushing data to file %q failed: pprof lookup returned null", p.filename)
		}

		err := file.Close()
		if err != nil {
			p.log("[ERROR] Block profiling flushing data to file %q failed: %s", p.filename, err.Error())
		}

		runtime.SetBlockProfileRate(0)
		p.log("[INFO] Block profiling disabled, file %s", fmt.Sprintf("%s%s", p.path, p.filename))
	}
}

// stopTraceMode stops trace profiling
func (p *Profile) stopTraceMode() func() {
	return func() {
		trace.Stop()
		p.log("[INFO] Trace disabled, file %s", fmt.Sprintf("%s%s", p.path, p.filename))
	}
}

// stopThreadCreationMode stops thread creation profiling
func (p *Profile) stopThreadCreationMode(file *os.File) func() {
	return func() {
		pprofile := pprof.Lookup(threadPprof)
		if pprofile != nil {
			err := pprofile.WriteTo(file, 0)
			if err != nil {
				p.log("[ERROR] Thread profiling flushing data to file %q failed: %s", p.filename, err.Error())
			}
		} else {
			p.log("[ERROR] Thread profiling flushing data to file %q failed: pprof lookup returned null", p.filename)
		}

		err := file.Close()
		if err != nil {
			p.log("[ERROR] Thread profiling flushing data to file %q failed: %s", p.filename, err.Error())
		}

		p.log("[INFO] Thread creation profiling disabled, file %s", fmt.Sprintf("%s%s", p.path, p.filename))
	}
}

// stopGoroutineMode stops goroutine profiling
func (p *Profile) stopGoroutineMode(file *os.File) func() {
	return func() {
		pprofile := pprof.Lookup(goroutinePprof)
		if pprofile != nil {
			err := pprofile.WriteTo(file, 0)
			if err != nil {
				p.log("[ERROR] Goroutine profiling flushing data to file %q failed: %s", p.filename, err.Error())
			}
		} else {
			p.log("[ERROR] Goroutine profiling flushing data to file %q failed: pprof lookup returned null", p.filename)
		}

		err := file.Close()
		if err != nil {
			p.log("[ERROR] Goroutine profiling flushing data to file %q failed: %s", p.filename, err.Error())
		}

		p.log("[INFO] Goroutine profiling disabled, file %s", fmt.Sprintf("%s%s", p.path, p.filename))
	}
}

// stopUnknownMode stops unknown profiling
func (p *Profile) stopUnknownMode() func() {
	return func() {
		p.log("[WARN] Which kind of profiling are you running?")
		p.log("[INFO] Unknown profiling disabled, file %s", fmt.Sprintf("%s%s", p.path, p.filename))
	}
}

// startShutdownHook starts a goroutine to wait for interruption signals and stop cleanly the profiling.
func (p *Profile) startShutdownHook() {
	if !p.disableShutdownHook {
		go func() {
			syscallCh := make(chan os.Signal)
			signal.Notify(syscallCh, syscall.SIGTERM, syscall.SIGINT, os.Interrupt)
			<-syscallCh

			// TODO replace with specific logger method
			p.log("[WARN] caught interrupt signal, stop profiling and flush to file")
			p.Stop()

			os.Exit(0)
		}()
	}
}

func (p *Profile) log(template string, args ...interface{}) {
	if !p.quiet {
		fmt.Printf(template, args...)
	}
}

// TODO work in progress

const (
	debugLevel logLevel = "debug"
	infoLevel  logLevel = "info"
	warnLevel  logLevel = "warn"
	errorLevel logLevel = "error"
	fatalLevel logLevel = "fatal"
)

type logLevel string

func (p *Profile) logf(level logLevel, template string, args ...interface{}) {
	if !p.quiet {
		if p.logger != nil {
			switch level {
			case debugLevel:
				p.logger.Debugf(template, args)
			case infoLevel:
				p.logger.Infof(template, args)
			case warnLevel:
				p.logger.Warnf(template, args)
			case errorLevel:
				p.logger.Errorf(template, args)
			case fatalLevel:
				p.logger.Fatalf(template, args)
			default:
				p.logger.Infof(template, args)
			}
		} else {
			fmt.Printf("[%s] %s", level, fmt.Sprintf(template, args...))
		}
	}
}
