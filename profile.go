// Package profile provides a simple way to manage multiple runtime/pprof profiling of your Go application
package profile

import (
	"fmt"
	"io/ioutil"
	"os"
	"os/signal"
	"path/filepath"
	"runtime"
	"runtime/pprof"
	"runtime/trace"
	"sync/atomic"
	"syscall"
)

const (
	cpuMode       profileMode = "cpu"
	memMode       profileMode = "mem"
	mutexMode     profileMode = "mutex"
	blockMode     profileMode = "block"
	traceMode     profileMode = "trace"
	threadMode    profileMode = "thread"
	goroutineMode profileMode = "goroutine"

	DefaultPath = "./"

	// DefaultMemProfileRate is the default memory profiling rate.
	// See also http://golang.org/pkg/runtime/#pkg-variables
	DefaultMemProfileRate = 4096

	// DefaultMemProfileRate is the default memory profiling type.
	DefaultMemProfileType = MemProfileHeap

	MemProfileHeap   MemProfileType = "heap"
	MemProfileAllocs MemProfileType = "allocs"

	debugLevel logLevel = "debug"
	infoLevel  logLevel = "info"
	warnLevel  logLevel = "warn"
	errorLevel logLevel = "error"
	fatalLevel logLevel = "fatal"
)

/*
	TODO
		. reduce duplication of 'stop*Mode' functions
*/

// Profile represents a profiling session
type Profile struct {
	// mode holds the type of profiling that will be made
	mode profileMode

	/*
		path holds the base path where various profiling files will be written.
		If blank, the base path will be the current directory "./"
	*/
	path string

	// useTempPath let the path be generated by "ioutil.TempDir"
	useTempPath bool

	// filePath holds the path to the file created by the profile
	filePath string

	// file holds the reference to the file created by the profile
	file *os.File

	// disableShutdownHook controls whether the profiling package should hook SIGINT to write profiles cleanly
	disableShutdownHook bool

	// quiet suppresses informational messages during profiling
	quiet bool

	/*
		memProfileRate holds the rate for the memory profile
		See DefaultMemProfileRate for default value
	*/
	memProfileRate int

	/*
		memProfileType holds the type for the memory profile
		Available values:   heap | allocs
		See DefaultMemProfileType for default
	*/
	memProfileType MemProfileType

	/*
		internalCloser holds the internal cleanup function that run after profiling Stop
		This function is specific for each profile (CPU, MEM, GoRoutines, etc)
	*/
	internalCloser func()

	// closerHook holds a custom cleanup function that run after profiling Stop
	closerHook func()

	// Logger offers the possibility to inject a custom logger
	logger Logger

	// previousMemProfileRate keeps track of the previous runtime.MemProfileRate value
	previousMemProfileRate int

	// started records if a call to profile.Start has already been made
	started uint32
}

// Config holds configurations to create a new Profile
type Config struct {
	/*
		Path holds the base path where various profiling files are  written
		If blank, the base path will be the current directory "./"
	*/
	Path string

	// UseTempPath let the path be generated by "ioutil.TempDir"
	UseTempPath bool

	// DisableShutdownHook controls whether the profiling package should hook SIGINT to write profiles cleanly
	DisableShutdownHook bool

	// Quiet suppresses informational messages during profiling
	Quiet bool

	/*
		MemProfileRate holds the rate for the memory profile
		See DefaultMemProfileRate for default value
	*/
	MemProfileRate int

	/*
		MemProfileType holds the type for the memory profile
		Available values:   heap | allocs
		See DefaultMemProfileType for default
	*/
	MemProfileType MemProfileType

	// CloserHook holds a custom cleanup function that run after profiling Stop
	CloserHook func()

	// Logger offers the possibility to inject a custom logger
	Logger Logger
}

// MemProfileType defines which type of memory profiling you want to start
type MemProfileType string

// profileMode defined which profiling mode has to be run
type profileMode string

// logLevel defines the level at which a message has to be logged
type logLevel string

type Logger interface {
	Debug(...interface{})
	Info(...interface{})
	Warn(...interface{})
	Error(...interface{})
	Fatal(...interface{})

	Debugf(string, ...interface{})
	Infof(string, ...interface{})
	Warnf(string, ...interface{})
	Errorf(string, ...interface{})
	Fatalf(string, ...interface{})
}

// CPUProfile creates a CPU profiling object
func CPUProfile(cfg *Config) *Profile {
	return &Profile{
		mode:                cpuMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		logger:              cfg.Logger,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// MemProfile creates a memory profiling object
func MemProfile(cfg *Config) *Profile {
	memRate := DefaultMemProfileRate
	memType := DefaultMemProfileType
	if cfg.MemProfileRate > 0 {
		memRate = cfg.MemProfileRate
	}
	if cfg.MemProfileType != "" {
		memType = cfg.MemProfileType
	}

	return &Profile{
		mode:                memMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		memProfileRate:      memRate,
		memProfileType:      memType,
		logger:              cfg.Logger,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// MutexProfile creates a mutex profiling object
func MutexProfile(cfg *Config) *Profile {
	return &Profile{
		mode:                mutexMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		logger:              cfg.Logger,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// BlockProfile creates a block (contention) profiling object
func BlockProfile(cfg *Config) *Profile {
	return &Profile{
		mode:                blockMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		logger:              cfg.Logger,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// TraceProfile creates an execution tracing profiling object
func TraceProfile(cfg *Config) *Profile {
	return &Profile{
		mode:                traceMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		logger:              cfg.Logger,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// ThreadCreationProfile creates a thread creation profiling object
func ThreadCreationProfile(cfg *Config) *Profile {
	return &Profile{
		mode:                threadMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		logger:              cfg.Logger,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// GoroutineProfile creates a goroutine profiling object
func GoroutineProfile(cfg *Config) *Profile {
	return &Profile{
		mode:                goroutineMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		logger:              cfg.Logger,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// Start starts a new profiling session
func (p *Profile) Start() *Profile {
	if !atomic.CompareAndSwapUint32(&p.started, 0, 1) {
		// no-op, profiling already started
		return p
	}

	var pathErr error
	if p.useTempPath {
		pathErr = p.prepareTempPath()
	} else {
		pathErr = p.preparePath()
	}
	if pathErr != nil {
		p.logf(errorLevel, "profiling start aborted, could not create output directory: %s", pathErr.Error())
		os.Exit(11)
	}

	switch p.mode {
	case cpuMode:
		p.startCpuMode()

	case memMode:
		p.startMemMode()

	case mutexMode:
		p.startMutexMode()

	case blockMode:
		p.startBlockMode()

	case traceMode:
		p.startTraceMode()

	case threadMode:
		p.startThreadCreationMode()

	case goroutineMode:
		p.startGoroutineMode()
	}

	p.startShutdownHook()
	return p
}

// Stop stops the profiling and flushes any unwritten data.
// The caller should call the Stop method on the value returned to cleanly stop profiling.
func (p *Profile) Stop() {
	if !atomic.CompareAndSwapUint32(&p.started, 1, 0) {
		// no-op, profiling already stopped
		return
	}

	if p.internalCloser != nil {
		p.internalCloser()
	}

	if p.closerHook != nil {
		p.closerHook()
	}
}

// startCpuMode starts cpu profiling
func (p *Profile) startCpuMode() {
	p.filePath = filepath.Join(p.path, "cpu.pprof")
	var fileErr error
	p.file, fileErr = os.Create(p.filePath)
	if fileErr != nil {
		p.logf(errorLevel, "CPU profiling file %q creation failed: %s", p.filePath, fileErr.Error())
		os.Exit(12)
	}

	startErr := pprof.StartCPUProfile(p.file)
	if startErr != nil {
		p.logf(errorLevel, "CPU profiling start failed: %s", startErr.Error())
		os.Exit(13)
	}
	p.internalCloser = p.stopCpuMode

	p.logf(infoLevel, "CPU profiling enabled, file %s", p.filePath)
}

// startMemMode starts memory profiling
func (p *Profile) startMemMode() {
	p.filePath = filepath.Join(p.path, "mem.pprof")
	var err error
	p.file, err = os.Create(p.filePath)
	if err != nil {
		p.logf(errorLevel, "Memory profiling (%s) file %q creation failed: %s", p.memProfileType, p.filePath, err.Error())
		os.Exit(12)
	}

	p.previousMemProfileRate = runtime.MemProfileRate
	runtime.MemProfileRate = p.memProfileRate
	p.internalCloser = p.stopMemMode

	p.logf(infoLevel, "Memory profiling (%s) enabled at rate %d, file %s",
		p.memProfileType, runtime.MemProfileRate, p.filePath)
}

// startMutexMode starts mutes profiling
func (p *Profile) startMutexMode() {
	p.filePath = filepath.Join(p.path, "mutex.pprof")
	var err error
	p.file, err = os.Create(p.filePath)
	if err != nil {
		p.logf(errorLevel, "Mutex profiling file %q creation failed: %s", p.filePath, err.Error())
		os.Exit(12)
	}

	runtime.SetMutexProfileFraction(1)
	p.internalCloser = p.stopMutexMode

	p.logf(infoLevel, "Mutex profiling enabled, file %s", p.filePath)
}

// startBlockMode starts block profiling
func (p *Profile) startBlockMode() {
	p.filePath = filepath.Join(p.path, "block.pprof")
	var err error
	p.file, err = os.Create(p.filePath)
	if err != nil {
		p.logf(errorLevel, "Block profiling file %q creation failed: %s", p.filePath, err.Error())
		os.Exit(12)
	}

	runtime.SetBlockProfileRate(1)
	p.internalCloser = p.stopBlockMode

	p.logf(infoLevel, "Block profiling enabled, file %s", p.filePath)
}

// startTraceMode starts trace profiling
func (p *Profile) startTraceMode() {
	p.filePath = filepath.Join(p.path, "trace.pprof")
	var fileErr error
	p.file, fileErr = os.Create(p.filePath)
	if fileErr != nil {
		p.logf(errorLevel, "Trace profiling file %q creation failed: %s", p.filePath, fileErr.Error())
		os.Exit(12)
	}

	startErr := trace.Start(p.file)
	if startErr != nil {
		p.logf(errorLevel, "Trace profiling start failed: %s", startErr.Error())
		os.Exit(14)
	}
	p.internalCloser = p.stopTraceMode

	p.logf(infoLevel, "Trace profiling enabled, file %s", p.filePath)
}

// startThreadCreationMode starts thread creation profiling
func (p *Profile) startThreadCreationMode() {
	p.filePath = filepath.Join(p.path, "thread.pprof")
	var err error
	p.file, err = os.Create(p.filePath)
	if err != nil {
		p.logf(errorLevel, "Thread creation profiling file %q creation failed: %s", p.filePath, err.Error())
		os.Exit(12)
	}
	p.internalCloser = p.stopThreadCreationMode

	p.logf(infoLevel, "Thread creation profiling enabled, file %s", p.filePath)
}

// startGoroutineMode starts goroutine profiling
func (p *Profile) startGoroutineMode() {
	p.filePath = filepath.Join(p.path, "goroutine.pprof")
	var err error
	p.file, err = os.Create(p.filePath)
	if err != nil {
		p.logf(errorLevel, "Goroutine profiling file %q creation failed: %s", p.filePath, err.Error())
		os.Exit(12)
	}
	p.internalCloser = p.stopGoroutineMode

	p.logf(infoLevel, "Goroutine profiling enabled, file %s", p.filePath)
}

// stopCpuMode stops cpu profiling
func (p *Profile) stopCpuMode() {
	pprof.StopCPUProfile()
	err := p.file.Close()
	if err != nil {
		p.logf(errorLevel, "CPU profiling flushing data to file %q failed: %s", p.filePath, err.Error())
	}

	p.logf(infoLevel, "CPU profiling disabled, file %s", p.filePath)
}

// stopMemMode stops memory profiling
func (p *Profile) stopMemMode() {
	pprofile := pprof.Lookup(string(p.memProfileType))
	if pprofile != nil {
		err := pprofile.WriteTo(p.file, 0)
		if err != nil {
			p.logf(errorLevel, "Memory profiling flushing data to file %q failed: %s", p.filePath, err.Error())
		}
	} else {
		p.logf(errorLevel, "Memory profiling flushing data to file %q failed: pprof lookup returned null", p.filePath)
	}

	err := p.file.Close()
	if err != nil {
		p.logf(errorLevel, "Memory profiling flushing data to file %q failed: %s", p.filePath, err.Error())
	}

	runtime.MemProfileRate = p.previousMemProfileRate
	p.previousMemProfileRate = -1
	p.logf(infoLevel, "Memory profiling disabled, file %s", p.filePath)
}

// stopMutexMode stops mutex profiling
func (p *Profile) stopMutexMode() {
	pprofile := pprof.Lookup("mutex")
	if pprofile != nil {
		err := pprofile.WriteTo(p.file, 0)
		if err != nil {
			p.logf(errorLevel, "Mutex profiling flushing data to file %q failed: %s", p.filePath, err.Error())
		}
	} else {
		p.logf(errorLevel, "Mutex profiling flushing data to file %q failed: pprof lookup returned null", p.filePath)
	}

	err := p.file.Close()
	if err != nil {
		p.logf(errorLevel, "Mutex profiling flushing data to file %q failed: %s", p.filePath, err.Error())
	}

	runtime.SetMutexProfileFraction(0)
	p.logf(infoLevel, "Mutex profiling disabled, file %s", p.filePath)
}

// stopBlockMode stops block profiling
func (p *Profile) stopBlockMode() {
	pprofile := pprof.Lookup("block")
	if pprofile != nil {
		err := pprofile.WriteTo(p.file, 0)
		if err != nil {
			p.logf(errorLevel, "Block profiling flushing data to file %q failed: %s", p.filePath, err.Error())
		}
	} else {
		p.logf(errorLevel, "Block profiling flushing data to file %q failed: pprof lookup returned null", p.filePath)
	}

	err := p.file.Close()
	if err != nil {
		p.logf(errorLevel, "Block profiling flushing data to file %q failed: %s", p.filePath, err.Error())
	}

	runtime.SetBlockProfileRate(0)
	p.logf(infoLevel, "Block profiling disabled, file %s", p.filePath)
}

// stopTraceMode stops trace profiling
func (p *Profile) stopTraceMode() {
	trace.Stop()
	p.logf(infoLevel, "Trace disabled, file %s", p.filePath)
}

// stopThreadCreationMode stops thread creation profiling
func (p *Profile) stopThreadCreationMode() {
	pprofile := pprof.Lookup("threadcreate")
	if pprofile != nil {
		err := pprofile.WriteTo(p.file, 0)
		if err != nil {
			p.logf(errorLevel, "Thread profiling flushing data to file %q failed: %s", p.filePath, err.Error())
		}
	} else {
		p.logf(errorLevel, "Thread profiling flushing data to file %q failed: pprof lookup returned null", p.filePath)
	}

	err := p.file.Close()
	if err != nil {
		p.logf(errorLevel, "Thread profiling flushing data to file %q failed: %s", p.filePath, err.Error())
	}

	p.logf(infoLevel, "Thread creation profiling disabled, file %s", p.filePath)
}

// stopGoroutineMode stops goroutine profiling
func (p *Profile) stopGoroutineMode() {
	pprofile := pprof.Lookup("goroutine")
	if pprofile != nil {
		err := pprofile.WriteTo(p.file, 0)
		if err != nil {
			p.logf(errorLevel, "Goroutine profiling flushing data to file %q failed: %s", p.filePath, err.Error())
		}
	} else {
		p.logf(errorLevel, "Goroutine profiling flushing data to file %q failed: pprof lookup returned null", p.filePath)
	}

	err := p.file.Close()
	if err != nil {
		p.logf(errorLevel, "Goroutine profiling flushing data to file %q failed: %s", p.filePath, err.Error())
	}

	p.logf(infoLevel, "Goroutine profiling disabled, file %s", p.filePath)
}

// stopUnknownMode stops unknown profiling
func (p *Profile) stopUnknownMode() func() {
	return func() {
		p.log(warnLevel, "Which kind of profiling are you running?")
		p.logf(infoLevel, "Unknown profiling disabled, file %s", p.filePath)
	}
}

// startShutdownHook starts a goroutine to wait for interruption signals and stop cleanly the profiling.
func (p *Profile) startShutdownHook() {
	if !p.disableShutdownHook {
		go func() {
			syscallCh := make(chan os.Signal)
			signal.Notify(syscallCh, syscall.SIGTERM, syscall.SIGINT, os.Interrupt)
			<-syscallCh

			p.log(warnLevel, "caught interrupt signal, stop profiling and flush to file")
			p.Stop()

			os.Exit(0)
		}()
	}
}

// preparePath prepares the file path to flush data into when profiling will be stopped
func (p *Profile) preparePath() error {
	if p.path == "" {
		p.path = DefaultPath
	}

	if p.path != DefaultPath {
		mkdirErr := os.MkdirAll(p.path, 0777)
		if mkdirErr != nil {
			return mkdirErr
		}
	}

	return nil
}

// preparePath prepares the file path in 'tmp' folder to flush data into when profiling will be stopped
func (p *Profile) prepareTempPath() error {
	var err error
	p.path, err = ioutil.TempDir("", "profile_")
	if err != nil {
		return err
	}
	return nil
}

// log abstracts the complexity of using an external specific logger
func (p *Profile) log(level logLevel, args ...interface{}) {
	if !p.quiet {
		if p.logger != nil {
			switch level {
			case debugLevel:
				p.logger.Debug(args...)
			case infoLevel:
				p.logger.Info(args...)
			case warnLevel:
				p.logger.Warn(args...)
			case errorLevel:
				p.logger.Error(args...)
			case fatalLevel:
				p.logger.Fatal(args...)
			default:
				p.logger.Info(args...)
			}
		} else {
			fmt.Print(fmt.Sprintf("[%s]", level), args, "\n")
		}
	}
}

// logf abstracts the complexity of using an external specific logger
func (p *Profile) logf(level logLevel, template string, args ...interface{}) {
	if !p.quiet {
		if p.logger != nil {
			switch level {
			case debugLevel:
				p.logger.Debugf(template, args...)
			case infoLevel:
				p.logger.Infof(template, args...)
			case warnLevel:
				p.logger.Warnf(template, args...)
			case errorLevel:
				p.logger.Errorf(template, args...)
			case fatalLevel:
				p.logger.Fatalf(template, args...)
			default:
				p.logger.Infof(template, args...)
			}
		} else {
			fmt.Printf("[%s] %s\n", level, fmt.Sprintf(template, args...))
		}
	}
}
