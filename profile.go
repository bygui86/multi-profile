// Package profile provides a simple way to manage multiple runtime/pprof profiling of your Go application.
package profile

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/signal"
	"path/filepath"
	"runtime"
	"runtime/pprof"
	"runtime/trace"
	"sync/atomic"
	"syscall"
)

const (
	cpuMode = iota
	memMode
	mutexMode
	blockMode
	traceMode
	threadCreationMode
	goroutineMode

	DefaultPath = "./"

	// DefaultMemProfileRate is the default memory profiling rate.
	// See also http://golang.org/pkg/runtime/#pkg-variables
	DefaultMemProfileRate = 4096

	// DefaultMemProfileRate is the default memory profiling type.
	DefaultMemProfileType = MemProfileHeap

	MemProfileHeap   MemProfileType = "heap"
	MemProfileAllocs MemProfileType = "allocs"

	cpuPprofDefaultFilename       = "cpu.pprof"
	memPprofDefaultFilename       = "mem.pprof"
	mutexPprofDefaultFilename     = "mutex.pprof"
	blockPprofDefaultFilename     = "block.pprof"
	tracePprofDefaultFilename     = "trace.pprof"
	threadPprofDefaultFilename    = "threadcreate.pprof"
	goroutingPprofDefaultFilename = "goroutine.pprof"

	mutexPprof     = "mutex"
	blockPprof     = "block"
	threadPprof    = "threadcreate"
	goroutinePprof = "goroutine"
)

type MemProfileType string

// Profile represents a profiling session.
type Profile struct {
	// mode holds the type of profiling that will be made.
	mode int

	/*
		path holds the base path where various profiling files are  written.
		If blank, the base path will be the current directory "./"
	*/
	path string

	// useTempPath let the path be generated by "ioutil.TempDir"
	useTempPath bool

	// filename holds the filename created by starting the profiling
	filename string

	// disableShutdownHook controls whether the profiling package should hook SIGINT to write profiles cleanly.
	disableShutdownHook bool

	// quiet suppresses informational messages during profiling.
	quiet bool

	/*
		memProfileRate holds the rate for the memory profile.
		See DefaultMemProfileRate for default value.
	*/
	memProfileRate int

	/*
		memProfileType holds the type for the memory profile.
		Available values:   heap | allocs
		See DefaultMemProfileType for default.
	*/
	memProfileType MemProfileType

	// internalCloser holds the internal cleanup function that run after profiling Stop.
	// This function is specific for each profile (CPU, MEM, GoRoutines, etc)
	internalCloser func()

	// closerHook holds a custom cleanup function that run after profiling Stop.
	closerHook func()

	// started records if a call to profile.Start has already been made.
	started uint32
}

// ProfileConfig holds configurations to create a new Profile
type ProfileConfig struct {
	/*
		Path holds the base path where various profiling files are  written.
		If blank, the base path will be the current directory "./"
	*/
	Path string

	// UseTempPath let the path be generated by "ioutil.TempDir"
	UseTempPath bool

	// DisableShutdownHook controls whether the profiling package should hook SIGINT to write profiles cleanly.
	DisableShutdownHook bool

	// Quiet suppresses informational messages during profiling.
	Quiet bool

	/*
		MemProfileRate holds the rate for the memory profile.
		See DefaultMemProfileRate for default value.
	*/
	MemProfileRate int

	/*
		MemProfileType holds the type for the memory profile.
		Available values:   heap | allocs
		See DefaultMemProfileType for default.
	*/
	MemProfileType MemProfileType

	// CloserHook holds a custom cleanup function that run after profiling Stop.
	CloserHook func()
}

// CPUProfile creates a CPU profiling object
func CPUProfile(cfg *ProfileConfig) *Profile {
	return &Profile{
		mode:                cpuMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// MemProfile creates a memory profiling object
func MemProfile(cfg *ProfileConfig) *Profile {
	memRate := DefaultMemProfileRate
	memType := DefaultMemProfileType
	if cfg.MemProfileRate > 0 {
		memRate = cfg.MemProfileRate
	}
	if cfg.MemProfileType != "" {
		memType = cfg.MemProfileType
	}

	return &Profile{
		mode:                memMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		memProfileRate:      memRate,
		memProfileType:      memType,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// MutexProfile creates a mutex profiling object
func MutexProfile(cfg *ProfileConfig) *Profile {
	return &Profile{
		mode:                mutexMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// BlockProfile creates a block (contention) profiling object
func BlockProfile(cfg *ProfileConfig) *Profile {
	return &Profile{
		mode:                blockMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// TraceProfile creates an execution tracing profiling object
func TraceProfile(cfg *ProfileConfig) *Profile {
	return &Profile{
		mode:                traceMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// ThreadCreationProfile creates a thread creation profiling object
func ThreadCreationProfile(cfg *ProfileConfig) *Profile {
	return &Profile{
		mode:                threadCreationMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// GoroutineProfile creates a goroutine profiling object
func GoroutineProfile(cfg *ProfileConfig) *Profile {
	return &Profile{
		mode:                goroutineMode,
		path:                cfg.Path,
		useTempPath:         cfg.UseTempPath,
		disableShutdownHook: cfg.DisableShutdownHook,
		quiet:               cfg.Quiet,
		closerHook:          cfg.CloserHook,
		started:             0,
	}
}

// Start starts a new profiling session.
func (p *Profile) Start() *Profile {
	if !atomic.CompareAndSwapUint32(&p.started, 0, 1) {
		// no-op, profiling already started
		return p
	}

	var pathErr error
	if p.useTempPath {
		pathErr = p.prepareTempPath()
	} else {
		pathErr = p.preparePath()
	}
	if pathErr != nil {
		// TODO replace with specific logger method
		p.log("[FATAL] profiling start aborted, could not create output directory: %s", pathErr.Error())
		os.Exit(11)
	}

	switch p.mode {
	case cpuMode:
		p.startCpuMode()

	case memMode:
		p.startMemMode()

	case mutexMode:
		p.startMutexMode()

	case blockMode:
		p.startBlockMode()

	case traceMode:
		p.startTraceMode()

	case threadCreationMode:
		p.startThreadCreationMode()

	case goroutineMode:
		p.startGoroutineMode()
	}

	p.startShutdownHook()
	return p
}

// Stop stops the profiling and flushes any unwritten data.
// The caller should call the Stop method on the value returned to cleanly stop profiling.
func (p *Profile) Stop() {
	if !atomic.CompareAndSwapUint32(&p.started, 1, 0) {
		// no-op, profiling already stopped
		return
	}

	if p.internalCloser != nil {
		p.internalCloser()
	}

	if p.closerHook != nil {
		p.closerHook()
	}
}

// preparePath prepares the file path to flush data into when profiling will be stopped.
func (p *Profile) preparePath() error {
	if p.path == "" {
		p.path = DefaultPath
	}

	if p.path != DefaultPath {
		mkdirErr := os.MkdirAll(p.path, 0777)
		if mkdirErr != nil {
			return mkdirErr
		}
	}

	return nil
}

// preparePath prepares the file path in 'tmp' folder to flush data into when profiling will be stopped.
func (p *Profile) prepareTempPath() error {
	var err error
	p.path, err = ioutil.TempDir("", "profile_")
	if err != nil {
		return err
	}
	return nil
}

// startCpuMode start cpu profiling
func (p *Profile) startCpuMode() {
	p.filename = filepath.Join(p.path, cpuPprofDefaultFilename)
	file, fileErr := os.Create(p.filename)
	if fileErr != nil {
		// TODO replace with specific logger method
		p.log("[FATAL] CPU profiling file %q creation failed: %s", p.filename, fileErr.Error())
		os.Exit(12)
	}
	startErr := pprof.StartCPUProfile(file)
	if startErr != nil {
		// TODO replace with specific logger method
		p.log("[FATAL] CPU profiling start failed: %s", startErr.Error())
		os.Exit(13)
	}
	p.internalCloser = p.stopAndFlush(file, -1)
	// TODO replace with specific logger method
	p.log("[INFO] CPU profiling enabled, file %s", fmt.Sprintf("%s%s", p.path, p.filename))
}

// startMemMode starts memory profiling
func (p *Profile) startMemMode() {
	p.filename = filepath.Join(p.path, memPprofDefaultFilename)
	file, err := os.Create(p.filename)
	if err != nil {
		// TODO replace with specific logger method
		p.log("[FATAL] Memory profiling file %q creation failed: %s", p.filename, err.Error())
		os.Exit(12)
	}
	previous := runtime.MemProfileRate
	runtime.MemProfileRate = p.memProfileRate
	p.internalCloser = p.stopAndFlush(file, previous)
	// TODO replace with specific logger method
	p.log("[INFO] Memory profiling enabled at rate %d, file %s",
		runtime.MemProfileRate, fmt.Sprintf("%s%s", p.path, p.filename))
}

// startMutexMode starts mutes profiling
func (p *Profile) startMutexMode() {
	p.filename = filepath.Join(p.path, mutexPprofDefaultFilename)
	file, err := os.Create(p.filename)
	if err != nil {
		// TODO replace with specific logger method
		p.log("[FATAL] Mutex profiling file %q creation failed: %s", p.filename, err.Error())
		os.Exit(12)
	}
	runtime.SetMutexProfileFraction(1)
	p.internalCloser = p.stopAndFlush(file, -1)
	// TODO replace with specific logger method
	p.log("[INFO] Mutex profiling enabled, file %s", fmt.Sprintf("%s%s", p.path, p.filename))
}

// startBlockMode starts block profiling
func (p *Profile) startBlockMode() {
	p.filename = filepath.Join(p.path, blockPprofDefaultFilename)
	file, err := os.Create(p.filename)
	if err != nil {
		// TODO replace with specific logger method
		p.log("[FATAL] Block profiling file %q creation failed: %s", p.filename, err.Error())
		os.Exit(12)
	}
	runtime.SetBlockProfileRate(1)
	p.internalCloser = p.stopAndFlush(file, -1)
	// TODO replace with specific logger method
	p.log("[INFO] Block profiling enabled, file %s", fmt.Sprintf("%s%s", p.path, p.filename))
}

// startTraceMode starts trace profiling
func (p *Profile) startTraceMode() {
	p.filename = filepath.Join(p.path, tracePprofDefaultFilename)
	file, fileErr := os.Create(p.filename)
	if fileErr != nil {
		// TODO replace with specific logger method
		p.log("[FATAL] Trace profiling file %q creation failed: %s", p.filename, fileErr.Error())
		os.Exit(12)
	}
	startErr := trace.Start(file)
	if startErr != nil {
		// TODO replace with specific logger method
		p.log("[FATAL] Trace profiling start failed: %s", startErr.Error())
		os.Exit(14)
	}
	p.internalCloser = p.stopAndFlush(file, -1)
	// TODO replace with specific logger method
	p.log("[INFO] Trace profiling enabled, file %s", fmt.Sprintf("%s%s", p.path, p.filename))
}

// startThreadCreationMode starts thread creation profiling
func (p *Profile) startThreadCreationMode() {
	p.filename = filepath.Join(p.path, threadPprofDefaultFilename)
	file, err := os.Create(p.filename)
	if err != nil {
		// TODO replace with specific logger method
		p.log("[FATAL] Thread creation profiling file %q creation failed: %s", p.filename, err.Error())
		os.Exit(12)
	}
	p.internalCloser = p.stopAndFlush(file, -1)
	// TODO replace with specific logger method
	p.log("[INFO] Thread creation profiling enabled, file %s", fmt.Sprintf("%s%s", p.path, p.filename))
}

// startGoroutineMode starts goroutine profiling
func (p *Profile) startGoroutineMode() {
	p.filename = filepath.Join(p.path, goroutingPprofDefaultFilename)
	file, err := os.Create(p.filename)
	if err != nil {
		// TODO replace with specific logger method
		p.log("[FATAL] Goroutine profiling file %q creation failed: %s", p.filename, err.Error())
		os.Exit(12)
	}
	p.internalCloser = p.stopAndFlush(file, -1)
	// TODO replace with specific logger method
	p.log("[INFO] Goroutine profiling enabled, file %s", fmt.Sprintf("%s%s", p.path, p.filename))
}

// stopAndFlush stops profiling and flush data to file.
func (p *Profile) stopAndFlush(file *os.File, previousMemRate int) func() {
	switch p.mode {

	case cpuMode:
		return func() {
			pprof.StopCPUProfile()
			err := file.Close()
			if err != nil {
				p.log("cpu profiling error flushing data to file %q: %s", p.filename, err.Error())
			}
			p.log("cpu profiling disabled (%q)", p.filename)
		}

	case memMode:
		return func() {
			pprofile := pprof.Lookup(string(p.memProfileType))
			if pprofile != nil {
				err := pprofile.WriteTo(file, 0)
				if err != nil {
					p.log("memory profiling error flushing data to file %q: %s", p.filename, err.Error())
				}
			} else {
				p.log("memory profiling error flushing data to file %q: pprof lookup returned null", p.filename)
			}
			err := file.Close()
			if err != nil {
				p.log("memory profiling error flushing data to file %q: %s", p.filename, err.Error())
			}
			runtime.MemProfileRate = previousMemRate
			p.log("memory profiling disabled (%q)", p.filename)
		}

	case mutexMode:
		return func() {
			pprofile := pprof.Lookup(mutexPprof)
			if pprofile != nil {
				err := pprofile.WriteTo(file, 0)
				if err != nil {
					p.log("mutex profiling error flushing data to file %q: %s", p.filename, err.Error())
				}
			} else {
				p.log("mutex profiling error flushing data to file %q: pprof lookup returned null", p.filename)
			}
			err := file.Close()
			if err != nil {
				p.log("mutex profiling error flushing data to file %q: %s", p.filename, err.Error())
			}
			runtime.SetMutexProfileFraction(0)
			p.log("mutex profiling disabled (%q)", p.filename)
		}

	case blockMode:
		return func() {
			pprofile := pprof.Lookup(blockPprof)
			if pprofile != nil {
				err := pprofile.WriteTo(file, 0)
				if err != nil {
					p.log("block profiling error flushing data to file %q: %s", p.filename, err.Error())
				}
			} else {
				p.log("block profiling error flushing data to file %q: pprof lookup returned null", p.filename)
			}
			err := file.Close()
			if err != nil {
				p.log("block profiling error flushing data to file %q: %s", p.filename, err.Error())
			}
			runtime.SetBlockProfileRate(0)
			p.log("block profiling disabled (%q)", p.filename)
		}

	case traceMode:
		return func() {
			trace.Stop()
			p.log("trace disabled (%q)", p.filename)
		}

	case threadCreationMode:
		return func() {
			pprofile := pprof.Lookup(threadPprof)
			if pprofile != nil {
				err := pprofile.WriteTo(file, 0)
				if err != nil {
					p.log("thread profiling error flushing data to file %q: %s", p.filename, err.Error())
				}
			} else {
				p.log("thread profiling error flushing data to file %q: pprof lookup returned null", p.filename)
			}
			err := file.Close()
			if err != nil {
				p.log("thread profiling error flushing data to file %q: %s", p.filename, err.Error())
			}
			p.log("thread creation profiling disabled (%q)", p.filename)
		}

	case goroutineMode:
		return func() {
			pprofile := pprof.Lookup(goroutinePprof)
			if pprofile != nil {
				err := pprofile.WriteTo(file, 0)
				if err != nil {
					p.log("goroutine profiling error flushing data to file %q: %s", p.filename, err.Error())
				}
			} else {
				p.log("goroutine profiling error flushing data to file %q: pprof lookup returned null", p.filename)
			}
			err := file.Close()
			if err != nil {
				p.log("goroutine profiling error flushing data to file %q: %s", p.filename, err.Error())
			}
			p.log("goroutine profiling disabled (%q)", p.filename)
		}

	// WARN: we should never reach default!
	default:
		return func() {
			p.log("unknown profiling disabled (%q)", p.filename)
		}
	}
}

// startShutdownHook starts a goroutine to wait for interruption signals and stop cleanly the profiling.
func (p *Profile) startShutdownHook() {
	if !p.disableShutdownHook {
		go func() {
			syscallCh := make(chan os.Signal)
			signal.Notify(syscallCh, syscall.SIGTERM, syscall.SIGINT, os.Interrupt)
			<-syscallCh

			// TODO replace with specific logger method
			p.log("[WARN] caught interrupt signal, stop profiling and flush to file")
			p.Stop()

			os.Exit(0)
		}()
	}
}

func (p *Profile) log(format string, args ...interface{}) {
	if !p.quiet {
		log.Printf(format, args...)
	}
}
